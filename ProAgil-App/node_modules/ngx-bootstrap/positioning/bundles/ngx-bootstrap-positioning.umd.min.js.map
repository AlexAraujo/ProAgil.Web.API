{"version":3,"sources":["../../../../src/positioning/utils/getStyleComputedProperty.ts","../../../../src/positioning/utils/isBrowser.ts","../../../../src/positioning/utils/isIE.ts","../../../../src/positioning/utils/getOffsetParent.ts","../../../../src/positioning/utils/getRoot.ts","../../../../src/positioning/utils/findCommonOffsetParent.ts","../../../../src/positioning/utils/isOffsetContainer.ts","../../../../src/positioning/utils/getFixedPositionOffsetParent.ts","../../../../src/positioning/utils/getBordersSize.ts","../../../../src/positioning/utils/getWindowSizes.ts","../../../../src/positioning/utils/getScroll.ts","../../../../src/positioning/utils/getClientRect.ts","../../../../src/positioning/utils/isNumeric.ts","../../../../src/positioning/utils/getBoundingClientRect.ts","../../../../src/positioning/utils/getParentNode.ts","../../../../src/positioning/utils/getScrollParent.ts","../../../../src/positioning/utils/getOffsetRectRelativeToArbitraryNode.ts","../../../../src/positioning/utils/includeScroll.ts","../../../../src/positioning/utils/isFixed.ts","../../../../src/positioning/utils/getBoundaries.ts","../../../../src/positioning/utils/getViewportOffsetRectRelativeToArtbitraryNode.ts","../../../../src/positioning/utils/computeAutoPlacement.ts","../../../../src/positioning/utils/getOuterSizes.ts","../../../../src/positioning/utils/getReferenceOffsets.ts","../../../../src/positioning/utils/getTargetOffsets.ts","../../../../src/positioning/utils/getOppositePlacement.ts","../../../../src/positioning/utils/isModifierEnabled.ts","../../../../src/positioning/utils/setStyles.ts","../../../../src/positioning/modifiers/arrow.ts","../../../../src/positioning/modifiers/flip.ts","../../../../src/positioning/utils/getOppositeVariation.ts","../../../../src/positioning/modifiers/preventOverflow.ts","../../../../src/positioning/modifiers/shift.ts","../../../../src/positioning/ng-positioning.ts","../../../../src/positioning/modifiers/initData.ts","../../../../src/positioning/utils/getOffsets.ts","../../../../src/positioning/utils/updateContainerClass.ts","../../../../src/positioning/positioning.service.ts"],"names":["getStyleComputedProperty","element","property","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","isBrowser","document","isIE11","MSInputMethodContext","documentMode","isIE10","test","navigator","userAgent","isIE","version","getOffsetParent","documentElement","noOffsetParent","body","offsetParent","sibling","nextElementSibling","nodeName","indexOf","getRoot","node","parentNode","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","firstElementChild","element1root","host","getFixedPositionOffsetParent","parentElement","el","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","html","computedStyle","_body","_html","_computedStyle","Math","max","parseInt","getWindowSizes","height","width","getScroll","side","upperSide","scrollingElement","getClientRect","offsets","Object","assign","right","left","bottom","top","isNumber","value","prototype","toString","call","getBoundingClientRect","rect","scrollTop","scrollLeft","e","result","sizes","undefined","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getParentNode","getScrollParent","_a","overflow","overflowX","overflowY","String","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","runIsIE","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","_b","_c","_d","_e","_f","marginTop","marginLeft","subtract","modifier","includeScroll","isFixed","getBoundaries","target","padding","boundariesElement","boundaries","excludeScroll","relativeOffset","innerWidth","innerHeight","Number","getViewportOffsetRectRelativeToArtbitraryNode","boundariesNode","computeAutoPlacement","placement","refRect","allowedPositions","rects","sortedAreas","keys","map","key","area","sort","a","b","filteredAreas","filter","computedPlacement","position","some","allowedPosition","length","variation","split","className","replace","parse","def","getOuterSizes","x","marginBottom","y","marginRight","getReferenceOffsets","getTargetOffsets","hostOffsets","targetRect","targetOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","hash","matched","getOppositePlacement","isModifierEnabled","options","modifierName","modifiers","enabled","setStyles","renderer","forEach","prop","n","unit","isNaN","isFinite","setStyle","style","arrow","data","arrowElement","instance","querySelector","isVertical","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","placementVariation","center","targetMarginSide","targetBorderSide","targetBorderRadius","borderRadius","targetSideArrowOffset","sideValue","min","_g","round","flip","adaptivePosition","flipOrder","step","index","overlapsRef","floor","_h","overflowsLeft","_j","_k","overflowsRight","_l","_m","overflowsTop","_o","_p","overflowsBottom","_q","_r","overflowsBoundaries","flippedVariation","getOppositeVariation","preventOverflow","targetStyles","transform","check","primary","secondary","shift","basePlacement","shiftVariation","shiftOffsets","Positioning","hostElement","targetElement","this","offset","positionElements","appendToBody","chainOfModifiers","hostElPosition","match","placementAuto","matches","positionFixed","initData","reduce","modifiedData","positionService","getOffsets","containerClass","setAttribute","updateContainerClass","PositioningService","ngZone","rendererFactory","platformId","_this","update$$","Subject","Map","isDisabled","isPlatformBrowser","runOutsideAngular","triggerEvent$","merge","fromEvent","passive","of","animationFrameScheduler","subscribe","positionElement","_getHtmlElement","attachment","createRenderer","addPositionElement","defineProperty","disable","enable","set","calcPosition","next","deletePositionElement","elRef","delete","setOptions","ElementRef","nativeElement","Injectable","args","providedIn","NgZone","RendererFactory2","Inject","PLATFORM_ID"],"mappings":"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","sourcesContent":["/**\n * Get CSS computed property of the given element\n */\nexport function getStyleComputedProperty(element: Element): CSSStyleDeclaration;\nexport function getStyleComputedProperty(element: Element, property?: string): string | string[];\nexport function getStyleComputedProperty(element: Element, property?: string): string | string[] | CSSStyleDeclaration {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const css = window?.getComputedStyle(element, null);\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return property ? css && css[property] : css;\n}\n","export const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n","/**\n * Determines if the browser is Internet Explorer\n */\nimport { isBrowser } from './isBrowser';\n\n// todo: valorkin fix and drop IE support :evil:\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext && (document as any).documentMode);\nconst isIE10 = isBrowser && !!(window.MSInputMethodContext && /MSIE 10/.test(navigator.userAgent));\n\nexport function isIE(version?: number) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n\n  return isIE11 || isIE10;\n}\n","/**\n * Returns the offset parent of the given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { isIE } from './isIE';\n\nexport function getOffsetParent(element: HTMLElement): HTMLElement {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent = element?.offsetParent;\n\n  // Skip hidden elements which don't have an offsetParent\n  let sibling: HTMLElement | undefined = void 0;\n\n  while (offsetParent === noOffsetParent\n         && element.nextElementSibling\n         && sibling !== element.nextElementSibling) {\n\n      // todo: valorkin fix\n      sibling = element.nextElementSibling as HTMLElement;\n      offsetParent = sibling.offsetParent;\n    }\n\n  const nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  if (\n    offsetParent &&\n    ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent, 'position') === 'static'\n  ) {\n    return getOffsetParent(offsetParent as HTMLElement);\n  }\n\n  return offsetParent as HTMLElement;\n}\n","/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\nexport function getRoot(node: Node|ShadowRoot): Node|ShadowRoot {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","/**\n * Finds the offset parent common to the two provided nodes\n */\nimport { isOffsetContainer } from './isOffsetContainer';\nimport { getRoot } from './getRoot';\nimport { getOffsetParent } from './getOffsetParent';\n\nexport function findCommonOffsetParent(element1: HTMLElement, element2: HTMLElement): HTMLElement {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n    const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  // Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n\n  // todo: valorkin fix\n  const commonAncestorContainer = range.commonAncestorContainer as unknown as HTMLElement;\n\n  // Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  ) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  const element1root = getRoot(element1) as ShadowRoot;\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host as HTMLElement, element2);\n  } else {\n    return findCommonOffsetParent(element1, (getRoot(element2) as ShadowRoot).host as HTMLElement);\n  }\n}\n","import { getOffsetParent } from './getOffsetParent';\n\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isOffsetContainer(element: any) {\n  const { nodeName } = element;\n  if (nodeName === 'BODY') {\n    return false;\n  }\n\n  return (\n    nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n * Finds the first parent of an element that has a transformed property defined\n */\n\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { isIE } from './isIE';\n\nexport function getFixedPositionOffsetParent(element: HTMLElement): HTMLElement {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n   return document.documentElement;\n  }\n\n  let el = element.parentElement;\n\n  while (el?.parentElement && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n\n  return el || document.documentElement;\n}\n","/**\n * Helper to detect borders of a given element\n */\n\nexport function getBordersSize(styles: CSSStyleDeclaration, axis: string): number {\n  const sideA = axis === 'x' ? 'Left' : 'Top';\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return (\n    parseFloat((styles as never)[`border${sideA}Width`]) +\n    parseFloat((styles as never)[`border${sideB}Width`])\n  );\n}\n","import { isIE } from './isIE';\n\nfunction getSize(axis: string, body: HTMLElement, html: HTMLElement, computedStyle?: CSSStyleDeclaration) {\n  const _body = body as unknown as Record<string, number>;\n  const _html = html as never;\n  const _computedStyle = computedStyle as unknown as Record<string, string>;\n\n  return Math.max(\n    _body[`offset${axis}`],\n    _body[`scroll${axis}`],\n    _html[`client${axis}`],\n    _html[`offset${axis}`],\n    _html[`scroll${axis}`],\n    isIE(10)\n      ? (parseInt(_html[`offset${axis}`], 10) +\n      parseInt(_computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`], 10) +\n      parseInt(_computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`], 10))\n    : 0\n  );\n}\n\nexport function getWindowSizes(document: Document) {\n  const body = document.body;\n  const html = document.documentElement;\n  const computedStyle = isIE(10) ? getComputedStyle(html) : void 0;\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n","/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\nexport function getScroll(element: HTMLElement, side = 'top') {\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    const html = element.ownerDocument.documentElement;\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\n\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n */\nimport { Offsets } from '../models';\n\nexport function getClientRect(offsets: Offsets): Offsets {\n  return {\n    ...offsets,\n    right: (offsets.left || 0) + offsets.width,\n    bottom: (offsets.top || 0) + offsets.height\n  };\n}\n","/**\n * Tells if a given input is a number\n */\nexport function isNumeric(n: string): boolean {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(Number(n));\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isNumber(value?: any): value is number {\n  return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n","/**\n * Get bounding client rect of given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getBordersSize } from './getBordersSize';\nimport { getWindowSizes } from './getWindowSizes';\nimport { getScroll } from './getScroll';\nimport { getClientRect } from './getClientRect';\nimport { isIE } from './isIE';\nimport { Offsets } from '../models';\nimport { isNumber } from './isNumeric';\n\nexport function getBoundingClientRect(element: HTMLElement): Offsets {\n  const rect: Offsets = element.getBoundingClientRect();\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      const scrollTop = getScroll(element, 'top');\n      const scrollLeft = getScroll(element, 'left');\n      if (rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right)) {\n        rect.top += scrollTop;\n        rect.left += scrollLeft;\n        rect.bottom += scrollTop;\n        rect.right += scrollLeft;\n      }\n    }\n  } catch (e) {\n    return rect;\n  }\n\n  if (!(rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right))) {\n    return rect;\n  }\n\n  const result: Offsets = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : undefined;\n  const width = sizes?.width || element.clientWidth\n    || isNumber(result.right) && isNumber(result.left) && result.right - result.left || 0;\n  const height = sizes?.height || element.clientHeight\n    || isNumber(result.bottom) && isNumber(result.top) && result.bottom - result.top || 0;\n\n  let horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n","/**\n * Returns the parentNode or the host of the element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getParentNode(element: any): any {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n\n  return element.parentNode || element.host;\n}\n","/**\n * Returns the scrolling parent of the given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getParentNode } from './getParentNode';\n\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getScrollParent(element: any): any {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n    default:\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","import { getBoundingClientRect } from './getBoundingClientRect';\nimport { getClientRect } from './getClientRect';\nimport { getScrollParent } from './getScrollParent';\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { includeScroll } from './includeScroll';\nimport { isIE as runIsIE } from './isIE';\nimport { Offsets } from '../models';\nimport { isNumber } from './isNumeric';\n\nexport function getOffsetRectRelativeToArbitraryNode(\n  children: HTMLElement,\n  parent: HTMLElement,\n  fixedPosition = false\n): Offsets {\n  const isIE10 = runIsIE(10);\n  const isHTML = parent.nodeName === 'HTML';\n  const childrenRect = getBoundingClientRect(children);\n  const parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top ?? 0, 0);\n    parentRect.left = Math.max(parentRect.left ?? 0, 0);\n  }\n\n  let offsets: Offsets = getClientRect({\n    top: (childrenRect.top ?? 0) - (parentRect.top ?? 0) - borderTopWidth,\n    left: (childrenRect.left ?? 0) - (parentRect.left ?? 0) - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    if (isNumber(offsets.top)) {\n      offsets.top -= borderTopWidth - marginTop;\n    }\n    if (isNumber(offsets.bottom)) {\n      offsets.bottom -= borderTopWidth - marginTop;\n    }\n    if (isNumber(offsets.left)) {\n      offsets.left -= borderLeftWidth - marginLeft;\n    }\n    if (isNumber(offsets.right)) {\n      offsets.right -= borderLeftWidth - marginLeft;\n    }\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10 && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent && scrollParent.nodeName !== 'BODY'\n  ) {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n","/**\n * Sum or subtract the element scroll values (left and top) from a given rect object\n */\nimport { getScroll } from './getScroll';\nimport { Offsets } from '../models';\nimport { isNumber } from './isNumeric';\n\nexport function includeScroll(rect: Offsets, element: HTMLElement, subtract = false) {\n  const scrollTop = getScroll(element, 'top');\n  const scrollLeft = getScroll(element, 'left');\n  const modifier = subtract ? -1 : 1;\n  if (isNumber(rect.top)) {\n    rect.top += scrollTop * modifier;\n  }\n  if (isNumber(rect.bottom)) {\n    rect.bottom += scrollTop * modifier;\n  }\n\n  if (isNumber(rect.left)) {\n    rect.left += scrollLeft * modifier;\n  }\n  if (isNumber(rect.right)) {\n    rect.right += scrollLeft * modifier;\n  }\n\n  return rect;\n}\n","/**\n * Check if the given element is fixed or is inside a fixed parent\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getParentNode } from './getParentNode';\n\nexport function isFixed(element: HTMLElement): boolean {\n  const nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n\n  return isFixed(getParentNode(element));\n}\n","/**\n * Computed the boundaries limits and return them\n */\nimport { Offsets } from '../models';\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getParentNode } from './getParentNode';\nimport { getScrollParent } from './getScrollParent';\nimport { getViewportOffsetRectRelativeToArtbitraryNode } from './getViewportOffsetRectRelativeToArtbitraryNode';\nimport { getWindowSizes } from './getWindowSizes';\nimport { isFixed } from './isFixed';\nimport { isNumber } from './isNumeric';\n\nexport function getBoundaries(\n  target: HTMLElement,\n  host: HTMLElement,\n  padding = 0,\n  boundariesElement: string,\n  fixedPosition = false\n): Partial<Offsets> {\n  // NOTE: 1 DOM access here\n\n  let boundaries: Partial<Offsets> = { top: 0, left: 0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    let boundariesNode;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    // In case of HTML, we need a different computation\n    if (offsets && boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(target.ownerDocument);\n      if (isNumber(boundaries.top) && isNumber(offsets.top) && isNumber(offsets.marginTop)) {\n        boundaries.top += offsets.top - offsets.marginTop;\n      }\n      if (isNumber(boundaries.top)) {\n        boundaries.bottom = Number(height) + Number(offsets.top);\n      }\n      if (isNumber(boundaries.left) && isNumber(offsets.left) && isNumber(offsets.marginLeft)) {\n        boundaries.left += offsets.left - offsets.marginLeft;\n      }\n      if (isNumber(boundaries.top)) {\n        boundaries.right = Number(width) + Number(offsets.left);\n      }\n    } else if (offsets) {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  if (isNumber(boundaries.left)) {\n    boundaries.left += padding;\n  }\n  if (isNumber(boundaries.top)) {\n    boundaries.top += padding;\n  }\n  if (isNumber(boundaries.right)) {\n    boundaries.right -= padding;\n  }\n  if (isNumber(boundaries.bottom)) {\n    boundaries.bottom -= padding;\n  }\n\n  return boundaries;\n}\n","import { getClientRect } from './getClientRect';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getScroll } from './getScroll';\nimport { Offsets } from '../models';\n\nexport function getViewportOffsetRectRelativeToArtbitraryNode(element: HTMLElement, excludeScroll = false): Offsets {\n  const html = element.ownerDocument.documentElement;\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  const offset = {\n    top: scrollTop - Number(relativeOffset?.top) + Number(relativeOffset?.marginTop),\n    left: scrollLeft - Number(relativeOffset?.left) + Number(relativeOffset?.marginLeft),\n    width,\n    height\n  };\n\n  return getClientRect(offset);\n}\n","/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\nimport { getBoundaries } from './getBoundaries';\nimport { Offsets } from '../models';\n\nfunction getArea({ width, height }: { width: number, height: number }) {\n  return width * height;\n}\n\nexport function computeAutoPlacement(\n  placement: string,\n  refRect: Offsets,\n  target: HTMLElement,\n  host: HTMLElement,\n  allowedPositions = ['top', 'bottom', 'right', 'left'],\n  boundariesElement = 'viewport',\n  padding = 0\n) {\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  const boundaries = getBoundaries(target, host, padding, boundariesElement);\n\n  type Rects = {top: Offsets, right: Offsets, bottom: Offsets, left: Offsets};\n  const rects: Rects = {\n    top: {\n      width: boundaries.width ?? 0,\n      height: refRect.top && boundaries.top ? refRect.top - boundaries.top : 0\n    },\n    right: {\n      width: boundaries.right && refRect.right ? boundaries.right - refRect.right : 0,\n      height: boundaries.height ?? 0\n    },\n    bottom: {\n      width: boundaries.width ?? 0,\n      height: boundaries.bottom && refRect.bottom ? boundaries.bottom - refRect.bottom: 0\n    },\n    left: {\n      width: refRect.left && boundaries.left ? refRect.left - boundaries.left : 0,\n      height: boundaries.height ?? 0\n    }\n  };\n\n  const sortedAreas = Object.keys(rects)\n    .map((key) => ({\n      key,\n      ...rects[key as keyof Rects],\n      area: getArea(rects[key as keyof Rects] as {width: number, height: number})\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  let filteredAreas = sortedAreas.filter(\n    ({ width, height }) => {\n      return width >= target.clientWidth\n        && height >= target.clientHeight;\n    }\n  );\n\n  filteredAreas = filteredAreas.filter((position) => {\n    return allowedPositions\n      .some((allowedPosition: string) => {\n        return allowedPosition === position.key;\n      });\n  });\n\n  const computedPlacement: string = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const variation = placement.split(' ')[1];\n\n  // for tooltip on auto position\n  target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${computedPlacement}`);\n\n  return computedPlacement + (variation ? `-${variation}` : '');\n}\n","/**\n * Get the outer sizes of the given element (offset size + margins)\n */\nimport { Offsets } from '../models';\n\nconst parse = (value?: string, def = 0) => value ? parseFloat(value) : def;\nexport function getOuterSizes(element: HTMLElement): Offsets {\n  const window = element.ownerDocument.defaultView;\n  const styles = window?.getComputedStyle(element);\n  const x = parse(styles?.marginTop) + parse(styles?.marginBottom);\n  const y = parse(styles?.marginLeft) + parse(styles?.marginRight);\n\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n","/**\n * Get offsets to the reference element\n */\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\nimport { Offsets } from '../models';\n\nexport function getReferenceOffsets(\n  target: HTMLElement,\n  host: HTMLElement,\n  fixedPosition?: boolean\n): Offsets {\n  const commonOffsetParent = fixedPosition\n    ? getFixedPositionOffsetParent(target)\n    : findCommonOffsetParent(target, host);\n\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n","/**\n * Get offsets to the target\n */\nimport { getOppositePlacement } from './getOppositePlacement';\nimport { getOuterSizes } from './getOuterSizes';\nimport { Offsets } from '../models';\n\nexport function getTargetOffsets(\n  target: HTMLElement,\n  hostOffsets: Offsets,\n  position: string\n): Offsets {\n  const placement = position.split(' ')[0];\n\n  // Get target node sizes\n  const targetRect = getOuterSizes(target);\n\n  // Add position, width and height to our offsets object\n  const targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  };\n\n  // depending by the target placement we have to compute its offsets slightly differently\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  targetOffsets[mainSide as keyof typeof targetOffsets] =\n    (hostOffsets[mainSide] ?? 0) +\n    hostOffsets[measurement] / 2 -\n    targetRect[measurement] / 2;\n\n  targetOffsets[secondarySide as keyof typeof targetOffsets] = placement === secondarySide\n    ? (hostOffsets[secondarySide] ?? 0)- targetRect[secondaryMeasurement]\n    : hostOffsets[getOppositePlacement(secondarySide) as keyof typeof hostOffsets] ?? 0;\n\n  return targetOffsets;\n}\n","/**\n * Get the opposite placement of the given one\n */\nexport function getOppositePlacement(placement: string): string {\n  const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched as keyof typeof hash]);\n}\n","/**\n * Helper used to know if the given modifier is enabled.\n */\nimport { Options } from '../models';\n\nexport function isModifierEnabled(options: Options, modifierName: string): boolean {\n  return !!options.modifiers[modifierName as keyof typeof options.modifiers]?.enabled;\n}\n","/**\n * Set the style to the given popper\n */\nimport { Renderer2 } from '@angular/core';\n\nimport { isNumeric } from './isNumeric';\n\nexport function setStyles(element: HTMLElement | null, styles?: Record<string, string|number|HTMLElement>, renderer?: Renderer2) {\n  if (!element || !styles) {\n    return;\n  }\n  Object.keys(styles).forEach((prop) => {\n    let unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n      isNumeric(styles[prop] as string)) {\n      unit = 'px';\n    }\n\n    if (renderer) {\n      renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n\n      return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (element.style as any)[prop] = String(styles[prop]) + unit;\n  });\n}\n","import { getClientRect, getOuterSizes, getStyleComputedProperty } from '../utils';\nimport { Data } from '../models';\n\nexport function arrow(data: Data) {\n  let targetOffsets = data.offsets.target;\n  // if arrowElement is a string, suppose it's a CSS selector\n  const arrowElement: HTMLElement | null = data.instance.target.querySelector('.arrow');\n\n  // if arrowElement is not found, don't run the modifier\n  if (!arrowElement) {\n    return data;\n  }\n\n  const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n\n  const len = isVertical ? 'height' : 'width';\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\n  const side = sideCapitalized.toLowerCase() as keyof typeof targetOffsets;\n  const altSide = isVertical ? 'left' : 'top';\n  const opSide = isVertical ? 'bottom' : 'right';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n  const placementVariation = data.placement.split(' ')[1];\n\n  // top/left side\n  if ((data.offsets.host[opSide] ?? 0) - arrowElementSize < (targetOffsets[side] ?? 0)) {\n    (targetOffsets)[side] -=\n      (targetOffsets[side] ?? 0) - ((data.offsets.host[opSide] ?? 0) - arrowElementSize);\n  }\n  // bottom/right side\n  if (Number((data).offsets.host[side]) + Number(arrowElementSize) > (targetOffsets[opSide] ?? 0)) {\n    (targetOffsets)[side] +=\n      Number((data).offsets.host[side]) + Number(arrowElementSize) - Number((targetOffsets)[opSide]);\n  }\n  targetOffsets = getClientRect(targetOffsets);\n\n  // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n  const css = getStyleComputedProperty(data.instance.target) as unknown as Record<string, string>;\n  const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]);\n  const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n\n  // compute center of the target\n  let center: number;\n  if (!placementVariation) {\n    center = Number((data).offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n  } else {\n    const targetBorderRadius = parseFloat(css.borderRadius);\n    const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n    center = side === placementVariation ?\n      Number((data).offsets.host[side]) + targetSideArrowOffset :\n      Number((data).offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n  }\n\n  let sideValue =\n    center - (targetOffsets[side] ?? 0) - targetMarginSide - targetBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its target\n  sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  data.instance.arrow = arrowElement;\n\n  return data;\n}\n","import { Data } from '../models';\nimport {\n  computeAutoPlacement,\n  getBoundaries,\n  getClientRect,\n  getOppositeVariation,\n  getTargetOffsets,\n  isModifierEnabled\n} from '../utils';\n\nexport function flip(data: Data): Data {\n  data.offsets.target = getClientRect(data.offsets.target);\n\n  if (!isModifierEnabled(data.options, 'flip')) {\n\n    data.offsets.target = {\n      ...data.offsets.target,\n      ...getTargetOffsets(\n        data.instance.target,\n        data.offsets.host,\n        data.placement\n      )\n    };\n\n    return data;\n  }\n\n  const boundaries = getBoundaries(\n    data.instance.target,\n    data.instance.host,\n    0, // padding\n    'viewport',\n    false // positionFixed\n  );\n\n  let placement = data.placement.split(' ')[0];\n  let variation = data.placement.split(' ')[1] || '';\n\n  const offsetsHost = data.offsets.host;\n  const target = data.instance.target;\n  const host = data.instance.host;\n\n  const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n  const flipOrder = [placement, adaptivePosition];\n\n  flipOrder.forEach((step, index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return;\n    }\n\n    placement = data.placement.split(' ')[0];\n\n    // using floor because the host offsets may contain decimals we are not going to consider here\n    const overlapsRef =\n      (placement === 'left' &&\n        Math.floor(data.offsets.target.right ?? 0) > Math.floor(data.offsets.host.left ?? 0)) ||\n      (placement === 'right' &&\n        Math.floor(data.offsets.target.left ?? 0) < Math.floor(data.offsets.host.right ?? 0)) ||\n      (placement === 'top' &&\n        Math.floor(data.offsets.target.bottom ?? 0) > Math.floor(data.offsets.host.top ?? 0)) ||\n      (placement === 'bottom' &&\n        Math.floor(data.offsets.target.top ?? 0) < Math.floor(data.offsets.host.bottom ?? 0));\n\n    const overflowsLeft = Math.floor(data.offsets.target.left ?? 0) < Math.floor(boundaries.left ?? 0);\n    const overflowsRight = Math.floor(data.offsets.target.right ?? 0) > Math.floor(boundaries.right ?? 0);\n    const overflowsTop = Math.floor(data.offsets.target.top ?? 0) < Math.floor(boundaries.top ?? 0);\n    const overflowsBottom = Math.floor(data.offsets.target.bottom ?? 0) > Math.floor(boundaries.bottom ?? 0);\n\n    const overflowsBoundaries =\n      (placement === 'left' && overflowsLeft) ||\n      (placement === 'right' && overflowsRight) ||\n      (placement === 'top' && overflowsTop) ||\n      (placement === 'bottom' && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    const flippedVariation =\n      ((isVertical && variation === 'left' && overflowsLeft) ||\n        (isVertical && variation === 'right' && overflowsRight) ||\n        (!isVertical && variation === 'left' && overflowsTop) ||\n        (!isVertical && variation === 'right' && overflowsBottom));\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? ` ${variation}` : '');\n\n      data.offsets.target = {\n        ...data.offsets.target,\n        ...getTargetOffsets(\n          data.instance.target,\n          data.offsets.host,\n          data.placement\n        )\n      };\n    }\n  });\n\n  return data;\n}\n","/**\n * Get the opposite placement variation of the given one\n */\nexport function getOppositeVariation(variation: string) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n\n  return variation;\n}\n","import { getBoundaries, isModifierEnabled } from '../utils';\nimport { Data, Offsets } from '../models';\n\nexport function preventOverflow(data: Data) {\n\n  if (!isModifierEnabled(data.options, 'preventOverflow')) {\n    return data;\n  }\n\n  // NOTE: DOM access here\n  // resets the target Offsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n  const transformProp = 'transform';\n  const targetStyles = data.instance.target.style; // assignment to help minification\n  const { top, left, [transformProp]: transform } = targetStyles;\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n\n  const boundaries = getBoundaries(\n    data.instance.target,\n    data.instance.host,\n    0, // padding\n    data.options.modifiers.preventOverflow?.boundariesElement || 'scrollParent',\n    false // positionFixed\n  );\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n\n  const order = ['left', 'right', 'top', 'bottom'];\n\n  const check = {\n    primary(placement: keyof Offsets) {\n      let value = data.offsets.target[placement];\n      // options.escapeWithReference\n      if ((data.offsets.target[placement] ?? 0) < (boundaries[placement] ?? 0)) {\n        value = Math.max(data.offsets.target[placement] ?? 0, boundaries[placement] ?? 0);\n      }\n\n      return { [placement]: value };\n    },\n    secondary(placement: keyof Offsets) {\n      const mainSide = placement === 'right' ? 'left' : 'top';\n      let value = data.offsets.target[mainSide];\n      // escapeWithReference\n      if ((data.offsets.target[placement] ?? 0) < (boundaries[placement] ?? 0)) {\n        value = Math.min(\n          data.offsets.target[mainSide] ?? 0,\n          (boundaries[placement] ?? 0) -\n          (placement === 'right' ? data.offsets.target.width : data.offsets.target.height)\n        );\n      }\n\n      return { [mainSide]: value };\n    }\n  };\n\n\n  order.forEach((placement ) => {\n    const side = ['left', 'top'].indexOf(placement) !== -1 ? check['primary'] : check['secondary'];\n\n    data.offsets.target = {\n      ...data.offsets.target,\n      ...side(placement as keyof Offsets)\n    };\n\n  });\n\n  return data;\n}\n","import { Data } from '../models';\n\nexport function shift(data: Data): Data {\n  const placement = data.placement;\n  const basePlacement = placement.split(' ')[0];\n  const shiftVariation = placement.split(' ')[1];\n\n  if (shiftVariation) {\n    const { host, target } = data.offsets;\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n\n    const shiftOffsets = {\n      start: { [side]: host[side] },\n      end: {\n        [side]: (host[side] ?? 0) + host[measurement] - target[measurement]\n      }\n    };\n\n    data.offsets.target = {\n      ...target, ...{\n        [side]: (side === shiftVariation ? shiftOffsets.start[side] : shiftOffsets.end[side])\n      }\n    };\n  }\n\n  return data;\n}\n","/**\n * @copyright Valor Software\n * @copyright Federico Zivolo and contributors\n */\nimport { Renderer2 } from '@angular/core';\nimport { Data, Offsets, Options } from './models';\n\nimport { arrow, flip, initData, preventOverflow, shift } from './modifiers';\n\nimport { getOffsets, getReferenceOffsets, setStyles, updateContainerClass } from './utils';\n\n\nexport class Positioning {\n  position(hostElement: HTMLElement, targetElement: HTMLElement/*, round = true*/): Offsets | undefined {\n    return this.offset(hostElement, targetElement/*, false*/);\n  }\n\n  offset(hostElement: HTMLElement, targetElement: HTMLElement/*, round = true*/): Offsets | undefined {\n    return getReferenceOffsets(targetElement, hostElement);\n  }\n\n  positionElements(\n    hostElement: HTMLElement | null,\n    targetElement: HTMLElement | null,\n    position: string,\n    appendToBody?: boolean,\n    options?: Options\n  ): Data | undefined {\n    const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n    const data = initData(targetElement, hostElement, position, options);\n    if (!data) {\n      return;\n    }\n\n    return chainOfModifiers.reduce(\n      (modifiedData, modifier) => modifier(modifiedData),\n      data\n    );\n  }\n}\n\nconst positionService = new Positioning();\n\nexport function positionElements(\n  hostElement: HTMLElement | null,\n  targetElement: HTMLElement | null,\n  placement: string,\n  appendToBody?: boolean,\n  options?: Options,\n  renderer?: Renderer2\n): void {\n\n  const data = positionService.positionElements(\n    hostElement,\n    targetElement,\n    placement,\n    appendToBody,\n    options\n  );\n\n  if (!data) {\n    return;\n  }\n\n  const offsets = getOffsets(data);\n\n  setStyles(targetElement, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n  }, renderer);\n\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n\n  updateContainerClass(data, renderer);\n}\n","import {\n  computeAutoPlacement,\n  getReferenceOffsets,\n  getTargetOffsets\n} from '../utils';\n\nimport { Data, Options } from '../models';\n\nexport function initData(\n  targetElement: HTMLElement|null, hostElement: HTMLElement|null, position: string, options?: Options\n): Data|undefined {\n\n  if (!targetElement || !hostElement) {\n    return ;\n  }\n\n  const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n\n  if (!position.match(/^(auto)*\\s*(left|right|top|bottom)*$/)\n    && !position.match(/^(left|right|top|bottom)*(?: (left|right|top|bottom))?\\s*(start|end)*$/)) {\n            position = 'auto';\n    }\n\n  const placementAuto = !!position.match(/auto/g);\n\n  // support old placements 'auto left|right|top|bottom'\n  let placement = position.match(/auto\\s(left|right|top|bottom)/)\n    ? position.split(' ')[1] || 'auto'\n    : position;\n\n  // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n  const matches = placement.match(/^(left|right|top|bottom)* ?(?!\\1)(left|right|top|bottom)?/);\n  if (matches) {\n    placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n  }\n\n  // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n  if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n    placement = 'auto';\n  }\n\n  const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n\n  placement = computeAutoPlacement(\n    placement,\n    hostElPosition,\n    targetElement,\n    hostElement,\n    options ? options.allowedPositions : undefined\n  );\n\n  return {\n    options: options || {modifiers: {}},\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: void 0\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: void 0\n    },\n    positionFixed: false,\n    placement,\n    placementAuto\n  };\n}\n","import { Data, Offsets } from '../models';\n\nexport function getOffsets(data: Data): Offsets {\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor(data.offsets.target.left ?? 0),\n    top: Math.round(data.offsets.target.top ?? 0),\n    bottom: Math.round(data.offsets.target.bottom ?? 0),\n    right: Math.floor(data.offsets.target.right ?? 0)\n  };\n}\n","/**\n * Update class for the given popper\n */\nimport { Renderer2 } from '@angular/core';\nimport { Data } from '../models';\n\nexport function updateContainerClass(data: Data, renderer?: Renderer2): void {\n  const target = data.instance.target;\n\n  let containerClass = target.className;\n\n  if (data.placementAuto) {\n    containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${data.placement}`);\n    containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${data.placement}`);\n    containerClass = containerClass.replace(/\\sauto/g, ` ${data.placement}`);\n\n    if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n      containerClass += ' popover-auto';\n    }\n\n    if (containerClass.indexOf('tooltip') !== -1  && containerClass.indexOf('tooltip-auto') === -1) {\n      containerClass += ' tooltip-auto';\n    }\n  }\n\n  containerClass = containerClass.replace(/left|right|top|bottom/g, `${data.placement.split(' ')[0]}`);\n\n  if (renderer) {\n    renderer.setAttribute(target, 'class', containerClass);\n\n    return;\n  }\n\n  target.className = containerClass;\n}\n","import { Injectable, ElementRef, RendererFactory2, Inject, PLATFORM_ID, NgZone } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\n\nimport { positionElements } from './ng-positioning';\n\nimport { fromEvent, merge, of, animationFrameScheduler, Subject, Observable } from 'rxjs';\nimport { Options } from './models';\n\n\nexport interface PositioningOptions {\n  /** The DOM element, ElementRef, or a selector string of an element which will be moved */\n  element?: HTMLElement | ElementRef | string;\n\n  /** The DOM element, ElementRef, or a selector string of an element which the element will be attached to  */\n  target?: HTMLElement | ElementRef | string;\n\n  /**\n   * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n   * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n   * not yet supported:\n   * - vert-attachment can be any of 'top', 'middle', 'bottom'\n   * - horiz-attachment can be any of 'left', 'center', 'right'\n   */\n  attachment?: string;\n\n  /** A string similar to `attachment`. The one difference is that, if it's not provided,\n   * `targetAttachment` will assume the mirror image of `attachment`.\n   */\n  targetAttachment?: string;\n\n  /** A string of the form 'vert-offset horiz-offset'\n   * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n   */\n  offset?: string;\n\n  /** A string similar to `offset`, but referring to the offset of the target */\n  targetOffset?: string;\n\n  /** If true component will be attached to body */\n  appendToBody?: boolean;\n}\n\n\n@Injectable({providedIn: 'root'})\nexport class PositioningService {\n  private options?: Options;\n  private update$$ = new Subject<null>();\n  private positionElements = new Map();\n  private triggerEvent$?: Observable<number|Event|null>;\n  private isDisabled = false;\n\n  constructor(\n    ngZone: NgZone,\n    rendererFactory: RendererFactory2,\n    @Inject(PLATFORM_ID) platformId: number\n  ) {\n\n    if (isPlatformBrowser(platformId)) {\n      ngZone.runOutsideAngular(() => {\n        this.triggerEvent$ = merge(\n          fromEvent(window, 'scroll', { passive: true }),\n          fromEvent(window, 'resize', { passive: true }),\n                    of(0, animationFrameScheduler),\n          this.update$$\n        );\n\n        this.triggerEvent$.subscribe(() => {\n          if (this.isDisabled) {\n            return;\n          }\n\n          this.positionElements\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .forEach((positionElement: any) => {\n              positionElements(\n                _getHtmlElement(positionElement.target),\n                _getHtmlElement(positionElement.element),\n                positionElement.attachment,\n                positionElement.appendToBody,\n                this.options,\n                rendererFactory.createRenderer(null, null)\n              );\n            });\n        });\n      });\n    }\n  }\n\n  position(options: PositioningOptions): void {\n    this.addPositionElement(options);\n  }\n\n  get event$(): Observable<number|Event|null>|undefined {\n    return this.triggerEvent$;\n  }\n\n  disable(): void {\n    this.isDisabled = true;\n  }\n\n  enable(): void {\n    this.isDisabled = false;\n  }\n\n  addPositionElement(options: PositioningOptions): void {\n    this.positionElements.set(_getHtmlElement(options.element), options);\n  }\n\n  calcPosition(): void {\n    this.update$$.next();\n  }\n\n  deletePositionElement(elRef: ElementRef): void {\n    this.positionElements.delete(_getHtmlElement(elRef));\n  }\n\n  setOptions(options: Options) {\n    this.options = options;\n  }\n}\n\nfunction _getHtmlElement(element?: HTMLElement | ElementRef | string): HTMLElement | null {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n\n  return element ?? null;\n}\n"]}